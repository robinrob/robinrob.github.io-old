<!DOCTYPE html><html lang=en><head><script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-71898998-1', 'auto');
ga('send', 'pageview');
</script><meta charset=utf-8><meta content=utf-8 name=content-type><meta content="text/html; charset=UTF-8" http-equiv=Content-Type><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width, initial-scale=1" name=viewport><meta content="Blog Post: When should you write unit tests? - Choosing when to write unit tests is not always a simple question" name=description><meta content="Freelance developer, Edinburgh, mobile, web, AngularJS, PhoneGap, SEO, Heroku, AWS, Google Apps, JavaScript, Force.com, Salesforce" name=keywords><title>When should you write unit tests?</title><link href=https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css rel=stylesheet type=text/css><link href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel=stylesheet type=text/css><link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel=stylesheet type=text/css><link href=/css/styles.css rel=stylesheet><link href=/img/favicon.gif rel=icon type=image/gif><link href="https://rsmith.io/blog/when-to-write-unit-tests//" rel=canonical></head><body><nav class="navbar navbar-default navbar-custom navbar-fixed-top"><div class=container-fluid><div class="navbar-header page-scroll"><button class=navbar-toggle data-target=#bs-example-navbar-collapse-1 data-toggle=collapse type=button><span class=sr-only>Toggle navigation</span> <span class=icon-bar></span> <span class=icon-bar></span> <span class=icon-bar></span></button></div><div class="collapse navbar-collapse" id=bs-example-navbar-collapse-1><ul class="nav navbar-nav"><li><a href="/"><span>Home page of Robin Smith's site</span> Home</a></li><li><a href=/#services><span>View software services that Robin Smith offers</span> Services</a></li><li><a href=/#projects><span>View projects that Robin Smith has previous worked on</span> Projects</a></li><li><a href=/#endorsements><span>View Robin Smith's endorsements</span> Endorsements</a></li><li><a href=/contact><span>Use contact form to contact Robin Smith</span> Contact</a></li><li><a href=/cv><span>View Robin Smith's CV</span> CV</a></li><li><a href=/blog><span>Read Robin Smith's Software development blog</span> Blog</a></li></ul></div></div></nav><header class=intro-header><div class="container post-heading"><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><h1>When should you write unit tests?</h1><h2 class=subheading>Choosing when to write unit tests is not always a simple question</h2></div></div></div></header><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=main><div class=blog><article><h2>Test-driven development?</h2><p>We&#39;ve probably all heard of <a href=https://en.wikipedia.org/wiki/Test-driven_development>TDD</a> (Test-Driven-Development) by now, with the idea behind TDD being to write your automated tests before the production code.</p><p>As with all software development practices, you&#39;ll find people with a whole range of opinions about the pros and cons of different approaches. These kind of debates usually have limited value after a certain point, because there is no single general solution. The debate can go round and round in circles but at some point you have to make a decision on what you&#39;re doing to do in a given scenario. I will describe the main principles I follow in deciding when to write tests.</p><h2>The value of writing automated tests</h2><p>Leaving aside the potential virtues of TDD for now, the value of having good automated tests <em>at all</em> far outstrips potential differences between writing them <em>before</em> or <em>after</em>. It&#39;s difficult to argue against the use of a good set of automated tests. The benefits are something I have thought about a lot; here are the main ones that come to mind:</p><ul><li><strong>Automated tests save you time</strong>. Manual testing is extremely time-consuming, and when you don&#39;t have automated tests, it&#39;s difficult to make any kind of incremental changes to your code and be confident that it still works. If you are doing lots of manual testing as you go, this will waste lots of precious time. If you make a lot of code changes and <em>then</em> everything all at once, things might be too broken to recover quickly.</li></ul><p>With automated tests, you can make many incremental changes and quickly validate them to ensure that you are not breaking fundamental functionality. You&#39;ll still want to do manual tests at the end of course, but knowing core logic is still working as you develop allows you to get on with changes quicker. Cutting out even a small percentage of the brutally-menial work of manual testing amounts to a huge time-saving.</p><p>Particularly for complex code, I find writing an automated test suite up-front to save me a lot of <em>overall</em> development time, before I begin counting on-going maintenance time. By the time the automated tests are passing and it comes to manual testing, it often turns out that things are <em>just working</em>. This is a great thing to experience.</p><ul><li><p><strong>Automated tests increase reliability</strong>. Since automated tests are <em>automated</em>, they always do their job properly. So if you are happy with your tests, and they pass, then you can be confident that in the worst case, your application is only minimally broken before you begin manual testing. The application will increase in reliability over time as bugs become known and tested for.</p></li><li><p><strong>Automated tests help you to understand the code</strong>. Whenever I need to remind myself of what a particular piece of code does, or I am familiarising myself with a new codebase, I always find reading the tests to be extremely helpful, especially if they are written such that they build up in a progression from simple to complex cases.</p></li><li><p><strong>Automated tests make refactoring much easier</strong>. Refactoring complex code that doesn&#39;t have tests is a <em>nightmare</em>! On a large, complex codebase, a good automated test suite will make refactoring vastly easier. If I was asked to refactor a complex codebase that lacked automated tests, I would consider writing those tests first. This would have the added benefit of forcing me to <em>really</em> understand how the code works, as well as the business domain.</p></li><li><p><strong>Writing tests helps with code design</strong>. I find the process of writing tests to be extremely useful in helping to resolve some design questions I may still have, when producing new code.</p></li><li><p><strong>Watching a test suite pass is extremely satisfying</strong>. Watching automated tests go from failing to passing is a great feeling. This can give you a very tangible feeling of momentum and confidence.</p></li></ul><h2>When <em>not</em> to write tests before code</h2><p>I&#39;ve found there is one obvious situation where you don&#39;t want to write the unit tests before you write the code: before the architecture of the code you&#39;re writing is fully defined.</p><p>Automated tests add inertia to change, and this is part of their value when used wisely, as it makes it harder for yourself or other developers to break things down the line. Therefore if you&#39;ve written a lot of tests and <em>then</em> change the design of the code being tested, you&#39;re going to experience a lot of pain, and the pain will damage your creative process.</p><p>There will still be some situations where the design will need to evolve at least a little as you start to actually implement it - it&#39;s hard to foresee everything at the start of writing a new codebase, especially if you are working in a new language or framework for example - in these cases it can be good to be sparing about the tests that you write first, then fill them in later.</p><h2>When to write tests before code</h2><h3>When the overall architecture is well-defined</h3><p>TDD works best in codebases where the overall architecture is already settled and robust, and you are just expanding the application horizontally - adding new features, and testing new algorithms. Everything is predictable on a large scale, and the only unknown is the correctness of the new code you are adding. So for example, you may be adding a new function to an existing service, adding a new service, or adding a new data model and associated DAO class.</p><p>In the above scenario, the overall structure to the tests you need to write will be obvious and predictable. Once you reach this point, you can be blindingly fast at adding new features, <em>and</em> having them well-tested. It is a win-win-win, and very enjoyable.</p><h3>Write tests whilst the domain and codebase knowledge are fresh</h3><p>I believe it is an important responsibility of the authors and modifiers of complex code, to be writing up automated tests that are needed as soon as the necessary knowledge of the domain or codebase has been gained. The overhead required of a developer later on to attain enough knowledge to write the tests themselves and start gaining the benefits of those tests, is very high. Even a small change to complex code would require a lot of time spent to fully understand the implications, if these are not made obvious by failing tests.</p><p>It can be a very stressful experience for a developer to have to make modifications to complex code that is not well-tested. If a great automated test suite is already there, the process becomes much easier and more enjoyable.</p><h2>Conclusion</h2><p>Software development is a technical and creative discipline, usually done in a business context. Decisions should be tailored to each scenario, and these can be highly varied in the life of a programmer.</p><p>The overall goal is to produce working code in the shortest time possible. The effort should go into fully understanding how each decision will affect the overall development time, possibly in non-obvious ways.</p><hr><span class=post-meta>Posted by Robin Smith on January 25, 2018</span></article><hr><ul class=pager><li class=previous><a data-placement=top data-toggle=tooltip href="/blog/dicsaurus-tool/" title=Dicsaurus>&larr; Previous Post</a></li><li class=next><a data-placement=top data-toggle=tooltip href="/blog/personal-automation-as-code-practice/" title="Personal automation as code practice">Next Post &rarr;</a></li></ul><div id=disqus_thread></div><script>
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://rsmith-io.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></div></div></div></div></div><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a href=mailto:robin@rsmith.io target=_blank><span>Send email to Robin Smith</span> <span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://github.com/robinrob target=_blank><span>Github page of Robin Smith</span> <span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-github fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://uk.linkedin.com/in/rsmithio target=_blank><span>LinkedIn profile page of Robin Smith</span> <span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-linkedin fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">Copyright Â© Robin Smith 2018</p></div></div></div></footer><script src=/js/scripts.js></script></body></html>