<!DOCTYPE html><html lang=en><head><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-71898998-1', 'auto');
  ga('send', 'pageview');
  </script><meta charset=utf-8><meta content=utf-8 name=content-type><meta content="text/html; charset=UTF-8" http-equiv=Content-Type><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width, initial-scale=1" name=viewport><meta content="Blog Post: When to write unit tests - Choosing when to write unit tests is not always a simple question" name=description><meta content="Freelance developer, Edinburgh, mobile, web, AngularJS, PhoneGap, SEO, Heroku, AWS, Google Apps, JavaScript, Force.com, Salesforce" name=keywords><title>When to write unit tests</title><link href=https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css rel=stylesheet type=text/css><link href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel=stylesheet type=text/css><link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel=stylesheet type=text/css><link href=/css/styles.css rel=stylesheet><link href=/img/favicon.gif rel=icon type=image/gif><link href="https://rsmith.io/blog/when-to-write-unit-tests/" rel=canonical></head><body><nav class="navbar navbar-default navbar-custom navbar-fixed-top"><div class=container-fluid><div class="navbar-header page-scroll"><button class=navbar-toggle data-target=#bs-example-navbar-collapse-1 data-toggle=collapse type=button><span class=sr-only>Toggle navigation</span> <span class=icon-bar></span> <span class=icon-bar></span> <span class=icon-bar></span></button></div><div class="collapse navbar-collapse" id=bs-example-navbar-collapse-1><ul class="nav navbar-nav"><li><a href="/"><span>Home page of Robin Smith's site</span> Home</a></li><li><a href=/#services><span>View software services that Robin Smith offers</span> Services</a></li><li><a href=/#projects><span>View projects that Robin Smith has previous worked on</span> Projects</a></li><li><a href=/#endorsements><span>View Robin Smith's endorsements</span> Endorsements</a></li><li><a href=/contact><span>Use contact form to contact Robin Smith</span> Contact</a></li><li><a href=/cv><span>View Robin Smith's CV</span> CV</a></li><li><a href=/blog><span>Read Robin Smith's Software development blog</span> Blog</a></li></ul></div></div></nav><header class=intro-header><div class="container post-heading"><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><h1>When to write unit tests</h1><h2 class=subheading>Choosing when to write unit tests is not always a simple question</h2></div></div></div></header><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=main><div class=blog><article><h2>Test-driven development?</h2><p>We&#39;ve all heard of TDD (Test-Driven-Development), with the idea behind TDD being to write your unit tests before you write the code which implements the functionality that you are testing.</p><p>As with all programming ideas, you will find people with a whole range of opinions about it. These kind of debates usually have limited value, because there is no one solution, the debate goes round in circles and at some point you have to make a decision on what you&#39;re doing to do in a given scenario.</p><h2>The value of automated tests</h2><p>Regarding unit tests, the value of having good automated tests <em>at all</em> far outstrips potential differences between writing them <em>before</em> or <em>after</em>. It&#39;s very hard to argue against the use of a good set of automated tests. Just to recap, some of the benefits are:</p><ul><li><p><strong>They save you time</strong>. Imagine if after every time you made a change to your code, you had to manually execute many commands or manually load the app to check every thing still works correctly.</p><p>This would be ridiculous. With automated tests, you can make many incremental changes without worrying about all that. You&#39;ll still want to do some manual tests at the end, but knowing core logic is still working as you develop allows you to get on with changes quicker. Cutting out even a small percentage of this brutally-menial work amounts to a huge time-saving.</p><p>For complex code, I find writing an automated test suite relatively early on to save me a lot of overall development time upfront, <a href=https://english.stackexchange.com/questions/12752/what-is-the-difference-between-nevermind-and-never-mind>never mind</a> on-going maintenance time. Automating testing is a natural programmer&#39;s instinct.</p></li><li><p><strong>They increase reliability</strong>. Automated tests are <em>automated</em>, so they always do their job properly.</p></li><li><p><strong>They help you to understand the code</strong>. Whenever I need to remind myself what a particular piece of code does, or am learning it for the first time, I always find reading the tests to be extremely helpful.</p></li><li><p><strong>They make refactoring much much easier</strong>. I can&#39;t imagine having to refactor complex code that doesn&#39;t have tests, as I&#39;ve never done it nor had to.</p></li><li><p><strong>Writing tests helps your code design</strong>. Besides the benefits of <em>having</em> unit tests I <em>writing</em> them to be extremely useful in helping me design the actual code, and the process of making them pass to also be very rewarding. It&#39;s something you have to experience to understand.</p></li></ul><h2>When <em>not</em> to write tests before code</h2><p>I&#39;ve found there is one obvious situation where you don&#39;t want to write the unit tests before you write the code: before the architecture of the code you&#39;re writing is fully defined.</p><p>Unit tests add inertia to change, and this is part of their value when used wisely, as it makes it harder for yourself or other developers to break things down the line. Therefore if you&#39;ve written a lot of tests and <em>then</em> change the design of the code being tested, you&#39;re going to experience a lot of pain. Experiencing this can give you added motivation to design the code upfront properly next time - which is a good practice anyway.</p><p>There are still some situations where the design will need to evolve as you start to actually implement it - it&#39;s hard to foresee everything at the start of writing a new codebase, especially if you are working in a new language or framework for example - in these cases be sparing about the tests that you write first, then fill them in later.</p><h2>When to write tests before code</h2><p>Writing tests first works best in codebases where the overall architecture is already settled-down and robust, and you are just expanding the app horizontally - adding new features, and testing new algorithms. Everything is predictable on a large scale, and the only unknown is the correctness of the new function you are adding.</p><h2>Write tests whilst the knowledge is fresh!</h2><p>I&#39;d say the second-most important factor in deciding when to write tests is - write them whilst the domain and codebase knowledge are fresh in your head - you, the developer who authored the code, or finds yourself working on code that is lacking in tests.</p><p>Not only does not writing tests for complex code leave a huge maintenance risk, but when other developers come to maintain your code later on, they will require extra time to understand the codebase and the ramifications of changing it. Being asked to modify complex code written by another developer, that is lacking in automated tests, is <em>scary</em> to me, and it should be. Whenever I find myself in that situation, I fill in the missing tests as soon as my domain and codebase knowledge have become complete enough. My professional pride and sense of duty demand it.</p><p>Fully understanding a business domain and the implications for the code are a <em>huge</em> overhead when the functionality and code are complex. Especially when the cost of a mistake is high - for example the code is dealing with costs or pricing. Being able to read a set of unit tests that build up in a logical progression from simple to complex cases, I personally find to speed up the process greatly. Not only does the familiarisation become quicker, but you have much more confidence in avoiding unexpectedly breaking things when making changes.</p><h2>Conclusion</h2><p>Coding is a technical and creative discipline, usually done in a business context. Decisions should be tailored to each scenario you find yourself in - and these can be highly varied in the career of a programmer - rather than driven by absolutist principles.</p><p>One thing is for sure - complex code <em>needs</em> tests, and seeing these tests passing is one of the thrills of being a developer.</p><hr><span class=post-meta>Posted by Robin Smith on February 2, 2018</span></article><hr><ul class=pager><li class=previous><a data-placement=top data-toggle=tooltip href=/blog/python-3-6-string-interpolation title="Python 3.6 string interpolation">&larr; Previous Post</a></li></ul></div></div></div></div></div><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a href=mailto:robin@rsmith.io target=_blank><span>Send email to Robin Smith</span> <span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://github.com/robinrob target=_blank><span>Github page of Robin Smith</span> <span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-github fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://uk.linkedin.com/in/rsmithio target=_blank><span>LinkedIn profile page of Robin Smith</span> <span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-linkedin fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">Copyright © Robin Smith 2018</p></div></div></div></footer><script src=/js/scripts.js></script></body></html>