<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Robin Smith - Freelance Web Developer</title>
    <description>Experienced full-stack web developer building custom web applications and integrations using the best frameworks and cloud technologies.
</description>
    <link>https://rsmith.io/</link>
    <atom:link href="https://rsmith.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Wed, 13 Jan 2016 19:23:15 +0000</pubDate>
    <lastBuildDate>Wed, 13 Jan 2016 19:23:15 +0000</lastBuildDate>
    <generator>Jekyll v2.4.0</generator>
    
      <item>
        <title>Maintaining a personal code library</title>
        <description>&lt;p&gt;These days rapid Google searches are an invaluable tool for developers who are constantly getting to grips with a
new language, framework or technique, where reading lengthy documentation would be a waste of time when the problem
is simply a matter of finding the correct syntax.&lt;/p&gt;

&lt;p&gt;Very very often I find the answer is much more valuable to me when shown in a way in which it is best understood by
myself. And there are certain things that when you are switching between languages on varying timescales, you find
yourself repeatedly needing to look up. They can often be unique to your particular style of coding - for example
it may be that you want to remind yourself of a particular pattern for implementing a decorator method in Python, or of
implementing a Class and inheritance structure in Javascript. The questions and answers are not always trivial.&lt;/p&gt;

&lt;p&gt;For this reason I am very careful to record in short scripts all such useful examples and commit and push these into
source code repositories that I maintain for myself. I have structured the repositories in a way (one repository per language,
split into &lt;code&gt;practice&lt;/code&gt; and &lt;code&gt;projects&lt;/code&gt; directories), that they are highly
amenable to searching by automated tool (usually ZSH function), so that usually to find the answer to a problem it is
a matter of running one command from wherever I happen to be, and I am instantly reminded of the code that I need.&lt;/p&gt;

&lt;p&gt;Holding onto your precious code is also a matter of pride in craft. Code does not often come cheap and can require
significant expenditure of your time to find good solutions. I do not want that time to go to waste by having to repeat
the process in future.&lt;/p&gt;
</description>
        <pubDate>Fri, 30 Oct 2015 00:00:00 +0000</pubDate>
        <link>https://rsmith.io/blog/personal-code-library</link>
        <guid isPermaLink="true">https://rsmith.io/blog/personal-code-library</guid>
        
        
      </item>
    
      <item>
        <title>Learn Regex or Regret It</title>
        <description>&lt;p&gt;Do you like challenging logic puzzles? Games that give you a set of root principles then offer up increasingly hard
problems that require ever-more creative ways of using the root principles to solve?&lt;/p&gt;

&lt;p&gt;I do, and once I actually sat down to dedicate some time to the subject of regular expressions, the
above viewpoint is the way in which I came to view this learning process. Learning how to use regular expressions is an exercise of
applying the known rules of the game to situations that require your creativity, logical thinking and intuition to solve.&lt;/p&gt;

&lt;p&gt;With all things that are difficult to do well, if you can make the process of mastering it into a game you will perform
much better. The task of solving regex problems is a &lt;em&gt;perfect&lt;/em&gt; candidate for game-making!&lt;/p&gt;

&lt;p&gt;If you only reach this stage in your appreciation of regular expressions then you may already find great value in them. But they
are also among one of the few truly powerful tools available to programmers that transcend programming language, framework
or project that you are working on. If you find Javascript to be a language worth learning because of its popularity
and relevance - a mere programming language, or AngularJS a framework worth learning because it&amp;#39;s popular at the
moment - then you should logically view a tool like regular expressions as being of great importance and relevance in your profession.
Regular expressions have been around for decades and have changed little in their basic philosophy and syntax.&lt;/p&gt;

&lt;p&gt;More important than any of the above great reasons for learning how to use regular expressions, the fact remains that they
are an incredibly powerful and efficient way of solving certain types of text-reading and text-manipulation problems.
To take a (simplified) example that is well-suited to the application of a regex solution: let&amp;#39;s say that you want
to read in some user input to specify the first line of an address, which must be a number followed by alphabetical
strings of characters, e.g. &amp;#39;41 Princes Street&amp;#39;. Furthermore, each alphabetical string must have its initial
character capitalised. So &amp;#39;41 123 Princes Street&amp;#39; would be invalid, as would &amp;#39;41 princes Street&amp;#39; or &amp;#39;41 Princes123 Street&amp;#39;. &lt;/p&gt;

&lt;p&gt;Let&amp;#39;s first solve the problem without using a regex. You may write some code like this (for example in Python):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;#!/usr/bin/env python

import sys

address = sys.argv[1]

parts = address.split(&#39; &#39;)

try:
    house_number = int(parts[0])
    street = parts[1:-1]

    for street_part in street:
        assert street_part.istitle() and street_part.isalpha()

    print &#39;Valid address!&#39;

except Exception as e:
    print &#39;Invalid address&#39;
    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An equivalent script using a regex method might go like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;#!/usr/bin/env python

import sys, re

address = sys.argv[1]

regex = re.compile(&#39;\A[0-9]+ ([A-Z][a-z]+\ ?)+\Z&#39;)
res = regex.match(address)

if hasattr(res, &#39;group&#39;):
    print &#39;Valid address!&#39;
    
else:
    print &#39;Invalid address&#39;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The regular expression says: match a string with the following properties:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Begins with a string of one more more digits&lt;/li&gt;
&lt;li&gt;The initial string of digits is followed by a space character, then one or more of: (alphabetical string with capitalised initial character, optionally followed by a space character)&lt;/li&gt;
&lt;li&gt;The string ends on the last of the occurrence of (alphabetical string with capitalised initial character, optionally followed by a space character)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For this particular example with the given constraints on the format of the address I would prefer the regular expression
solution, as it expresses very concisely the conditions being imposed for validity of the input. For me it is a lot
easier to write and to read and therefore easier to get right and to not make mistakes. It also utilises a neat aspect
of regular expressions: recursive matching of a sub-expression (the alphabetical strings following the number in the address
line).&lt;/p&gt;

&lt;p&gt;Not every instance of any given type of problem is best solved using any particular tool, and this is true with regular 
expressions. A judgement must be made based on many factors and constraints on which is the best method to use to solve the problem,
where &amp;#39;best&amp;#39; is defined by a lot of factors specific to the problem and the environment and circumstances in which it is being solved.
Regular expressions are just one additional tool that you have available for consideration when making this decision.&lt;/p&gt;

&lt;p&gt;The reason why I think that it would be regretful not to learn how to use regular expressions, is that since making the
effort to learn how to use this tool, I have personally encountered many situations where they have been a priceless tool, saving
me time and frustration, and giving a feeling of satisfaction when the correct regex for a problem is discovered! It&amp;#39;s
not often that such a simple, short string of characters can give such power.&lt;/p&gt;
</description>
        <pubDate>Sat, 29 Aug 2015 00:00:00 +0100</pubDate>
        <link>https://rsmith.io/blog/learn-regex-or-regret-it</link>
        <guid isPermaLink="true">https://rsmith.io/blog/learn-regex-or-regret-it</guid>
        
        
      </item>
    
      <item>
        <title>Faster Variable Debugging</title>
        <description>&lt;p&gt;Almost inevitably whilst debugging code, regardless of any additional tools that you may have available (e.g.
browser development tools when debugging front-end code), it can be desirable to quickly print the contents of a
variable to the program output. Maybe you don&amp;#39;t have the time to learn how to use a more comprehensive tool in that moment,
or doing so would actually take more time. You can find yourself repetitively typing the same mundane set of characters
out that results in printing something in the language that you happen to be using.&lt;/p&gt;

&lt;p&gt;I use my terminal extensively for little time-saving pieces of automation, that over the course of a day can have a big
impact on your efficiency. One example is a set of short commands for printing things out in various languages:&lt;/p&gt;

&lt;h2&gt;Javascript&lt;/h2&gt;

&lt;h3&gt;&lt;code&gt;js_log&lt;/code&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;copy_print &quot;console.log(&#39;$(upper $*)&#39;)&quot;&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;&lt;code&gt;copy_print&lt;/code&gt; (ZSH function)&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;zsh&quot;&gt;copy_print () {
    printf $@ | pbcopy &amp;&amp; pbpaste
}&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;&lt;code&gt;upper&lt;/code&gt; (ZSH function)&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;zsh&quot;&gt;upper () {
    print $@:u
}&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;&lt;code&gt;js_log_object&lt;/code&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;console.log(&#39;myVar: &#39; + JSON.stringify(myVar, null, &#39;\t&#39;))&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Python&lt;/h2&gt;

&lt;h3&gt;&lt;code&gt;python_log&lt;/code&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;python_log () {
    copy_print &quot;print &#39;$(upper $*)&#39;&quot;
}&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;&lt;code&gt;python_log_var&lt;/code&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;python_log_var () {
    copy_print &quot;print &#39;$1: {var}&#39;.format(var=$1)&quot;
}&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;&lt;code&gt;python_log_object&lt;/code&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;python_log_object () {
    copy_print &quot;import simplejson as simplejson; print &#39;$1: {json}&#39;.format(json=simplejson.dumps($1, indent=4))&quot;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You get the idea. Usage is simple, like this (after hot-keying to your terminal window and here using an alias &lt;code&gt;logpo&lt;/code&gt; for &lt;code&gt;log_python_object&lt;/code&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;zsh&quot;&gt;âš¡ logpo my_var
import simplejson as simplejson; print &#39;my_var: {json}&#39;.format(json=simplejson.dumps(my_var, indent=4))%
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above printed snippet is then in the clipboard and you can just paste it into the code where you want it, which of course
prints when run:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;my_var: {
    &quot;age&quot;: 28,
    &quot;name&quot;: &quot;Robin&quot;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is fun in automating out repetitive actions that really bring down your day. It&amp;#39;s also a handy way to learn ZSH
and discover command-line tools.&lt;/p&gt;
</description>
        <pubDate>Tue, 25 Aug 2015 00:00:00 +0100</pubDate>
        <link>https://rsmith.io/blog/faster-variable-debugging</link>
        <guid isPermaLink="true">https://rsmith.io/blog/faster-variable-debugging</guid>
        
        
      </item>
    
      <item>
        <title>ConsoleWriter jQuery Plugin</title>
        <description>&lt;h2 class=&quot;console-writer&quot; cw-sound=&quot;true&quot; cw-animation=&quot;true&quot;&gt;Edit Me!&lt;/h2&gt;

&lt;p&gt;I wanted to create a console-like typing effect on a heading element, with the heading firstly 
appearing character by character as if being typed in at a developer&amp;#39;s console. This sort of thing has already been done
as in &lt;a href=&quot;http://www.mattboldt.com/demos/typed-js/&quot;&gt;Typed.js&lt;/a&gt;,
&lt;a href=&quot;http://codepen.io/voronianski/pen/aicwk&quot;&gt;typeWriter.js&lt;/a&gt; or
&lt;a href=&quot;https://github.com/fardjad/realistic-typewriter.js&quot;&gt;realistic-typewriter.js&lt;/a&gt;. As with most ideas in the JS
world or software world, it is fair to say that this idea has been done before.&lt;/p&gt;

&lt;p&gt;My main motivation for the project was to gain familiarity with using jQuery and I believe that embarking on a pet
project is the best, most fun and most productive way to learn a new programming language or framework. &lt;/p&gt;

&lt;p&gt;The main objective I wanted to achieve was actually to allow the site visitor to modify the heading element by focusing it,
deleting existing characters and typing whatever they wanted into the element, complete with a blinking cursor at the end
of the line as in a terminal. I also added keyboard typing sounds to heighten the effect. Try it now by clicking any of
the headings within this blog article.&lt;/p&gt;

&lt;h2 class=&quot;console-writer&quot; cw-typing-sound=&quot;true&quot;&gt;ConsoleWriter&lt;/h2&gt;

&lt;p&gt;I packaged the project up as a jQuery plugin: &lt;a href=&quot;https://github.com/robinrob/consolewriter.jquery.js&quot;&gt;ConsoleWriter&lt;/a&gt;,
designed with a focus on user-friendliness and configurability using options. The heading above this paragraph displays the default method of usage which requires
just adding the &lt;code&gt;console-writer&lt;/code&gt; class to the element. Reload the page again to see the typewriter effect. The &lt;code&gt;readme&lt;/code&gt;
file included in the repo describes the options and how to set them. There is also a &lt;code&gt;demo.html&lt;/code&gt; file which shows
example usages.&lt;/p&gt;
</description>
        <pubDate>Wed, 01 Jul 2015 00:00:00 +0100</pubDate>
        <link>https://rsmith.io/blog/console-writer-jquery-plugin</link>
        <guid isPermaLink="true">https://rsmith.io/blog/console-writer-jquery-plugin</guid>
        
        
      </item>
    
      <item>
        <title>Jekyll Gulp HAML SASS BrowserSync</title>
        <description>&lt;p&gt;Whilst using Github&amp;#39;s Jekyll framework to build a static website, I noticed a lack of built-in HAML support. I am a big fan of using HAML to produce HTML. Apart from this lack of support for HAML, I enjoy using Jekyll.&lt;/p&gt;

&lt;p&gt;Since I was using Gulp to manage the build process, I needed a Gulp task to handle the HAML preprocessing. I initially tried using the &lt;a href=&quot;https://www.npmjs.com/package/gulp-haml&quot;&gt;&lt;span&gt;Gulp-Haml NPM package&lt;/span&gt;gulp-haml&lt;/a&gt; module in my HAML task, but it produced incorrect results a few times. I came across the node module &lt;a href=&quot;https://github.com/moneypenny/gulp-ruby-haml&quot;&gt;&lt;span&gt;Gulp-Ruby-Haml NPM package&lt;/span&gt;gulp-ruby-haml&lt;/a&gt;, which is a wrapper on the Ruby gem &lt;a href=&quot;https://rubygems.org/gems/haml&quot;&gt;&lt;span&gt;HAML ruby package&lt;/span&gt;haml&lt;/a&gt;, and which gives accurate results.&lt;/p&gt;

&lt;h2 class=&quot;section-heading&quot;&gt;HAML Processing&lt;/h2&gt;

&lt;p&gt;HAML files reside inside a &lt;code&gt;_haml&lt;/code&gt; folder which sits at the location of the resultant HTML files. For example:
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;project-root
        index
                _haml
                        index.haml
                index.html
        _includes
                _haml
                        footer.haml
                        head.haml
                        nav.haml
                footer.html
                head.html
                nav.html
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;The HAML build task is actually fairly slow compared to the CSS or Javascript processing tasks. It can take up to 10 seconds to process all of the HAML in the project. This is unacceptable when rebuilding on-the-fly while making changes.&lt;/p&gt;

&lt;p&gt;To avoid slow build times, I use a separate &lt;code&gt;haml-watch&lt;/code&gt; task that watches the HAML files for changes, then only processes the files that changed. The stream is then piped into the code for compiling the HAML, which is contained in the function &lt;code&gt;hamlBuild()&lt;/code&gt;. This stream-piping step makes use of &lt;a href=&quot;https://www.npmjs.com/package/stream-combiner2&quot;&gt;&lt;span&gt;Stream Combiner 2 NPM package&lt;/span&gt;stream-combiner2&lt;/a&gt;. Below is the code for both HAML tasks:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;var haml = require(&#39;gulp-ruby-haml&#39;)
var combiner = require(&#39;stream-combiner2&#39;)

...

var config = {
    paths: {
        ...
        haml: {
            src: [&#39;**/_haml/*.haml&#39;]
        },
        ...
    }
}

...

/* hamlBuild() contains the shared build logic used by haml-watch and haml-build */
function hamlBuild() {
    return combiner(
        haml(),
        rename(function (path) {
            path.dirname += &#39;/../&#39;
        })
    )
}

/* Watch and compile only changed HAML files to HTML.
 * haml-watch has its own task to avoid doing a full HAML build on each .haml file change, since a full HAML build
 * can be quite slow.
 */
gulp.task(&#39;haml-watch&#39;, function () {
    gulp.src(config.paths.haml.src, {read: false})
        .pipe(watch(config.paths.haml.src))
        .pipe(hamlBuild())
        .pipe(gulp.dest(&#39;./&#39;))
})

/* Compile all HAML files to HTML. */
gulp.task(&#39;haml-build&#39;, function () {
    return gulp.src(config.paths.haml.src)
        .pipe(hamlBuild())
        .pipe(gulp.dest(&#39;./&#39;))
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 class=&quot;section-heading&quot;&gt;Full Site Template&lt;/h2&gt;

&lt;p&gt;Whilst researching Jekyll, I noticed a few other people sharing their Jekyll setups as site templates. Here is my own &lt;a href=&quot;https://github.com/robinrob/jekyll-gulp-haml-sass-browsersync.git&quot;&gt;&lt;span&gt;Source repository for Jekyll-Gulp-Haml-Sass-Browsersync project&lt;/span&gt;jekyll-gulp-haml-sass-browsersync&lt;/a&gt; template which includes my full &lt;a href=&quot;https://github.com/robinrob/jekyll-gulp-haml-sass-browsersync/blob/master/gulpfile.js&quot;&gt;&lt;span&gt;Gulpfile for Jekyll-Gulp-Haml-Sass-Browsersync project on source repository page&lt;/span&gt;Gulpfile&lt;/a&gt;.&lt;/p&gt;
</description>
        <pubDate>Thu, 04 Jun 2015 00:00:00 +0100</pubDate>
        <link>https://rsmith.io/blog/jekyll-gulp-haml-sass-browsersync</link>
        <guid isPermaLink="true">https://rsmith.io/blog/jekyll-gulp-haml-sass-browsersync</guid>
        
        
      </item>
    
      <item>
        <title>RSS Reader Script</title>
        <description>&lt;p&gt;I wanted a quick, lightweight way to browse and open articles from RSS feeds from within the terminal. I wrote a short
&lt;a href=&quot;https://github.com/robinrob/rss-opener.git&quot;&gt;&lt;span&gt;Source code repository for RSS Reader Script project&lt;/span&gt;&lt;/a&gt; for quickly opening RSS feed articles in a web browser.&lt;/p&gt;

&lt;h2&gt;Screenshot&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/rss-opener.png&quot; alt=&quot;RSS Reader Usage Screenshot&quot;&gt;&lt;/p&gt;

&lt;p&gt;Further details on its usage are given in the README file in the project.&lt;/p&gt;
</description>
        <pubDate>Sun, 24 May 2015 00:00:00 +0100</pubDate>
        <link>https://rsmith.io/blog/rss-feed-reader</link>
        <guid isPermaLink="true">https://rsmith.io/blog/rss-feed-reader</guid>
        
        
      </item>
    
  </channel>
</rss>
