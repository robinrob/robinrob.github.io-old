<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Robin Smith - Full-stack Web Developer</title>
    <description>Experienced full-stack web developer building custom web applications and integrations using the best frameworks and cloud technologies.
</description>
    <link>https://rsmith.io/</link>
    <atom:link href="https://rsmith.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sat, 17 Feb 2018 15:28:47 +0000</pubDate>
    <lastBuildDate>Sat, 17 Feb 2018 15:28:47 +0000</lastBuildDate>
    <generator>Jekyll v3.7.2</generator>
    
      <item>
        <title>Deciding What to Learn Next as a Programmer</title>
        <description>&lt;p&gt;The fields of web and mobile software development appear to change very quickly, with new languages (and versions of
languages) and frameworks appearing all the time. There are also countless named methodologies for how to go
about software development.&lt;/p&gt;

&lt;p&gt;New features are appearing in languages all the time, through specific updates to existing
languages - for example: Lambdas and first-class functions in Java 8, generators in ECMAScript 6) - to more general
trends like the increasing inclusion of functional programming concepts in modern languages, particularly in new
languages like Swift where there is the opportunity to start completely afresh. (Of course it&amp;#39;s not that
functional programming ideas are new!).&lt;/p&gt;

&lt;p&gt;To a curious-minded developer, languages and even frameworks are fun to learn almost for their own sake, particularly new ones.
Each language has its own character and subtly leads you into doing things in particular ways. Sometimes these
new methods solve problems that you&amp;#39;ve often come across whilst using other languages, so there is excitement at the
prospect of future benefit from the new features or from the approach. There is an emotional response to the creative aspects of the
language, to things as simple as its appearance or empathy for particular decisions its designers have made.&lt;/p&gt;

&lt;p&gt;When a language update or new language makes a big deal about a computer science concept that you&amp;#39;re not familiar with, it can serve
as a nice introduction and an extra mxotivator to go and learn about it, or to refresh your knowledge about it.&lt;/p&gt;

&lt;p&gt;As you climb up the stack and the new things become higher and higher-level, or the multiplicities of new things becomes
greater, it becomes more and more necessary to be pragmatic about what you spend your time on. The hierarchy of knowledge
and skills that I need, as I see it, goes roughly (from low- to high-level):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Mathematics&lt;/li&gt;
&lt;li&gt;Creativity&lt;/li&gt;
&lt;li&gt;Computer science&lt;/li&gt;
&lt;li&gt;Programming languages&lt;/li&gt;
&lt;li&gt;Software design&lt;/li&gt;
&lt;li&gt;Databases&lt;/li&gt;
&lt;li&gt;Web protocols (e.g. HTTP, SSH)&lt;/li&gt;
&lt;li&gt;Cloud technologies&lt;/li&gt;
&lt;li&gt;Web frameworks&lt;/li&gt;
&lt;li&gt;Libraries&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All of the above areas of skills and knowledge are required in order to make complex web applications. As you go down
the list, the concepts become higher and higher-level, they become easier and easier to create from scratch and examples
of them become more and more numerous.&lt;/p&gt;

&lt;p&gt;Things like computer science knowledge and software design are skills that a developer needs to be able to apply to all
software development situations. Practical and thorough understanding of these comes through actually making applications,
in diverse scenarios. So to some extent is necessary to delve into multiple programming languages and application
frameworks.&lt;/p&gt;

&lt;p&gt;At some point though you have to start being pragmatic about what is worth spending time on learning. Once a developer
has learned several languages or frameworks, acquiring new ones becomes quite easy and inexpensive. For me, usually
following a book and making a moderately complex personal project gives me ~95% of the knowledge and fluency I need in any
 particular language or framework, in order to be really effective with it professionally. Different projects are going to use different aspects
of languages or frameworks to lesser and greater amounts, so as long as you have knowledge of a bit of everything,
any codebase is going to be recognisable.&lt;/p&gt;

&lt;p&gt;My personal emphasis is towards spending more time actually making things. Given an initial concept,
I am confident that I can create what I set out to, choosing the tool that feels best for the particular project at that particular time.
However it is still important to keep up with the trends by doing things like reading blogs or &lt;a href=&quot;https://news.ycombinator.com&quot;&gt;Hacker News&lt;/a&gt;, or going
to technology meet-ups, and anything else that helps keep you up-to-date.&lt;/p&gt;

&lt;p&gt;It can feel as though a lot of emphasis gets placed on the virtues of having experience with a given new web framework, as
it suddenly becomes popular. And of course over time, these new ways of doing things are healthy as a way of gradually
optimising ways of working, keeping up with the changing demands of web software as the infrastructure becomes more
powerful over time.&lt;/p&gt;

&lt;p&gt;But I do think it&amp;#39;s important to keep the focus on the fundamentals - the fundamental skills
of being able to choose the right tool or language to use, to write software that is structured nicely, and to make
usable applications. I think these are the real differentiators between developers, are the most valuable to aspire to and take the most time to learn
in the first place. A word of warning: this approach does tend to make you most-suited to hipster startup environments.&lt;/p&gt;

&lt;p&gt;Therefore for me the natural conclusion is to spend good time at every level of the &amp;#39;knowledge stack&amp;#39;, on an on-going basis
(always stay humble and open to new ideas and knowledge), but to prioritise towards the fundamentals. A great way
to encourage all of that is to keep making things, incorporating the new things that you learn, making each codebase
a bit better than the last.&lt;/p&gt;
</description>
        <pubDate>Fri, 16 Feb 2018 00:00:00 +0000</pubDate>
        <link>https://rsmith.io/blog/deciding-what-to-learn-next/</link>
        <guid isPermaLink="true">https://rsmith.io/blog/deciding-what-to-learn-next/</guid>
        
        
      </item>
    
      <item>
        <title>Encoding &amp; Decoding Swift 4 Models</title>
        <description>&lt;p&gt;Tee-ell-dee-argh: view my code examples as a &lt;a href=&quot;https://github.com/robinrob/swift-4-model-coding/blob/master/swift-4-model-coding/CodableTest.swift&quot;&gt;single file&lt;/a&gt;.
Running the &lt;a href=&quot;https://github.com/robinrob/swift-4-model-coding&quot;&gt;project&lt;/a&gt; in xcode runs the examples and displays some
output for each.&lt;/p&gt;

&lt;p&gt;Whilst working on &lt;a href=&quot;https://github.com/robinrob/guitar-chords&quot;&gt;GuitarChords&lt;/a&gt; (a personal iOS project of mine for
displaying guitar chord variations) I found
 myself wanting to be able to pre-load the native SQLite database with data serialised in a JSON file. The motivation
 for this was because my app deals with a bunch of data that I&amp;#39;ve pre-calculated and which doesn&amp;#39;t change -
 variations of guitar chords. But I still wanted the database functionality for querying the records quickly.&lt;/p&gt;

&lt;p&gt;I&amp;#39;ve since decided that I don&amp;#39;t need the database layer after all, as I am only dealing with ~several hundred records.
  After more thought I realised that the costs of having an extra persistence layer (e.g. handling app
   updates on users&amp;#39; devices) in my case are not worth any potential
  advantages that might be gained over holding all of that data in memory, compared to simply loading the data in from
  the JSON on each app load.&lt;/p&gt;

&lt;p&gt;Storing the pre-calculated data as static JSON effectively keeps the app stateless in that aspect.
  This also makes serialisation and de-serialisation a bit easier, as I can take full
  advantage of Swift 4&amp;#39;s built-in Encoding/Decoding API.&lt;/p&gt;

&lt;p&gt;Nevertheless it was still a fairly interesting process to get things working, so I&amp;#39;ll give some code examples
  of encoding &amp;amp; decoding objects in Swift, building up to combining serialisation with persistence, and perhaps it&amp;#39;ll
  help somebody else who does need to do this, or myself in future.&lt;/p&gt;

&lt;h2&gt;Codable&lt;/h2&gt;

&lt;p&gt;Swift documentation is good and the best place to start for this topic is
&lt;a href=&quot;https://developer.apple.com/documentation/foundation/archives_and_serialization/encoding_and_decoding_custom_types&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;Encoding a Struct (into JSON)&lt;/h3&gt;

&lt;p&gt;If the instance variables of a type that you want to encode all implement the &lt;code&gt;Encodable&lt;/code&gt; protocol, then Swift will
encode the whole thing automatically. So for instance a Struct consisting only of standard built-in Swift types (which
implement the &lt;code&gt;Encodable&lt;/code&gt; protocol) can be easily converted into JSON:&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;swift small-code&quot;&gt;struct CodableStruct: Codable {
    var name: String
    var age: Int
}

static func encodeStructAsJSON() {
    let obj = CodableStruct(name: &quot;Robin&quot;, age: 30)
    do {
        let encoder = JSONEncoder()
        encoder.outputFormatting = .prettyPrinted
        let data = try encoder.encode(obj)
        let json = String(data: data, encoding: .utf8)!
        print(&quot;json: \(json)&quot;)
    } catch {
        print(&quot;encoding error: \(error)&quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;pre class=&quot;plaintext&quot;&gt;&lt;code class=&quot;plaintext small-code&quot;&gt;json: {
  &quot;name&quot; : &quot;Robin&quot;,
  &quot;age&quot; : 30
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Encoding a Class&lt;/h3&gt;

&lt;p&gt;The same thing above also works for a Class whose instance variables all implement &lt;code&gt;Encodable&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;swift small-code&quot;&gt;class CodableClass: Codable {
    var name: String
    var age: Int

    init(name: String, age: Int) {
        self.name = name
        self.age = age
    }
}

static func encodeClassAsJSON() {
    let obj = CodableClass(name: &quot;Robin&quot;, age: 30)
    do {
        let encoder = JSONEncoder()
        encoder.outputFormatting = .prettyPrinted
        let data = try encoder.encode(obj)
        let json = String(data: data, encoding: .utf8)!
        print(&quot;json: \(json)&quot;)
    } catch {
        print(&quot;encoding error: \(error)&quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;pre class=&quot;plaintext&quot;&gt;&lt;code class=&quot;plaintext small-code&quot;&gt;json: {
  &quot;name&quot; : &quot;Robin&quot;,
  &quot;age&quot; : 30
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Decoding a Struct (from JSON)&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;swift small-code&quot;&gt;static func decodeStructFromJSON() {
    let json = &quot;{\&quot;name\&quot;:\&quot;Robin\&quot;,\&quot;age\&quot;:30}&quot;

    do {
        let obj = try JSONDecoder().decode(
            CodableStruct.self,
            from: json.data(using: .utf8)!
        )
        print(&quot;obj.name: \(obj.name)&quot;)
    } catch {
        print(&quot;encoding error: \(error)&quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;pre class=&quot;plaintext&quot;&gt;&lt;code class=&quot;plaintext small-code&quot;&gt;obj.name: Robin
person.age: 30
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Decoding a Class&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;swift small-code&quot;&gt;static func decodeClassFromJSON() {
    let json = &quot;{\&quot;name\&quot;:\&quot;Robin\&quot;,\&quot;age\&quot;:30}&quot;

    do {
        let obj = try JSONDecoder().decode(
            CodableClass.self,
            from: json.data(using: .utf8)!
        )
        print(&quot;obj.name: \(obj.name)&quot;)
        print(&quot;person.age: \(String(obj.age))&quot;)
    } catch {
        print(&quot;decoding error: \(error)&quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;pre class=&quot;plaintext&quot;&gt;&lt;code class=&quot;plaintext small-code&quot;&gt;obj.name: Robin
person.age: 30
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Encoding a Database model class&lt;/h3&gt;

&lt;p&gt;It gets more tricky when you want to directly encode/decode a class which represents one of your database models, because
 we need to do custom decoding &amp;amp; encoding. It looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;swift small-code&quot;&gt;@objc(PersonModel)
final class PersonModel: NSManagedObject, Encodable, Decodable {
    init(from decoder: Decoder) {
        super.init(
            entity: NSEntityDescription.entity(
                forEntityName: &quot;PersonModel&quot;,
                in: context
            )!,
            insertInto: context
        )

        do {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.name = try container.decode(type(of: self.name), forKey: .name)
            self.age = try container.decode(type(of: self.age), forKey: .age)
        } catch {
            print(&quot;decoding error: \(error)&quot;)
        }
    }

    private override init(
        entity: NSEntityDescription,
        insertInto context: NSManagedObjectContext?
    ) {
        super.init(entity: entity, insertInto: context)
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self.name, forKey: .name)
        try container.encode(self.age, forKey: .age)
    }

    enum CodingKeys: CodingKey {
        case name
        case age
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;context&lt;/code&gt; is an in-memory store (also useful for unit testing on models!) created by the following function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;swift small-code&quot;&gt;func getBackgroundContextForTesting(
    forModelType modelType: AnyClass
) -&gt; NSManagedObjectContext {
    let managedObjectModel = NSManagedObjectModel.mergedModel(
        from: [Bundle(for: modelType)]
    )!

    let container = NSPersistentContainer(
        name: &quot;PersonModel&quot;,
        managedObjectModel: managedObjectModel
    )
    let description = NSPersistentStoreDescription()
    description.type = NSInMemoryStoreType

    container.persistentStoreDescriptions = [description]
    container.loadPersistentStores { (description, error) in
        precondition( description.type == NSInMemoryStoreType )

        if let error = error {
            fatalError(&quot;Creating in-memory coordinator failed \(error)&quot;)
        }
    }
    return container.newBackgroundContext()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then finally, encoding the database model class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;swift small-code&quot;&gt;static func encodeModelAsJSON() {
    let obj = NSEntityDescription.insertNewObject(
        forEntityName: &quot;PersonModel&quot;,
        into: context
        ) as! PersonModel

    obj.name = &quot;Robin&quot;
    obj.age = 30

    do {
        let encoder = JSONEncoder()
        encoder.outputFormatting = .prettyPrinted
        let data = try encoder.encode(obj)
        let json = String(data: data, encoding: .utf8)!
        print(&quot;json: \(json)&quot;)
    } catch {
        print(&quot;encoding error: \(error)&quot;)
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;output:&lt;/p&gt;

&lt;pre class=&quot;plaintext&quot;&gt;&lt;code class=&quot;plaintext small-code&quot;&gt;json: {
  &quot;name&quot; : &quot;Robin&quot;,
  &quot;age&quot; : 30
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Decoding a Database model class&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;swift small-code&quot;&gt;static func decodeModelFromJSON() {
    let json = &quot;{\&quot;name\&quot;: \&quot;Robin\&quot;,\&quot;age\&quot;: 30}&quot;
    do {
        let person = try JSONDecoder().decode(
            PersonModel.self,
            from: json.data(using: .utf8)
        !)
        try context.save()
        print(&quot;person.name: \(person.name!)&quot;)
        print(&quot;person.age: \(String(person.age))&quot;)
    } catch {
        print(&quot;decoding error: \(error)&quot;)
    }
}
&lt;/pre&gt;&lt;/code&gt;

output:

&lt;pre class=&quot;plaintext&quot;&gt;&lt;code class=&quot;plaintext small-code&quot;&gt;obj.name: Robin
person.age: 30
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Thu, 08 Feb 2018 00:00:00 +0000</pubDate>
        <link>https://rsmith.io/blog/encoding-decoding-swift-models/</link>
        <guid isPermaLink="true">https://rsmith.io/blog/encoding-decoding-swift-models/</guid>
        
        
      </item>
    
      <item>
        <title>What's so Fun About Programming?</title>
        <description>&lt;p&gt;I wouldn&amp;#39;t be the first to discuss this question but it&amp;#39;s something I&amp;#39;ve often thought about, and having made great
efforts in the past to cross over from a different field into software development, often asked myself. I&amp;#39;m worried
that I&amp;#39;m about to come off as a bit of a &lt;a href=&quot;https://en.wikipedia.org/wiki/List_of_regular_mini-sections_in_Private_Eye#Pseuds_Corner&quot;&gt;pseud&lt;/a&gt; though.&lt;/p&gt;

&lt;p&gt;I&amp;#39;m going to be biased, but it seems to me that programmers are on average relatively highly-motivated, and
passionate about what they do. This is not unique to programming by any means, and I think this is mainly down to two things:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Programming is a highly technical and specialised skill&lt;/li&gt;
&lt;li&gt;Programming is highly creative&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;When a field is highly technical, of course it takes a lot of motivation from the start to develop the knowledge and skills required to be
productive in it. Therefore similarly, you find a high occurrence of motivated doctors and surgeons within their profession.
You wouldn&amp;#39;t expect to ever be seen by an unmotivated doctor or surgeon, and I&amp;#39;ve never met one. I actually enjoy going into hospitals
partly for this reason.&lt;/p&gt;

&lt;p&gt;Programming combines the technical with the artistic, in a similar way that architecture does in the hardware world. I think
people thrive on creativity. Especially in an increasingly bureaucratic and corporate world, the chance to add
your personal touch to something in a tangible way is perhaps correspondingly more desirable. I certainly feel like
that myself, and over time I&amp;#39;ve been picking up more and more creative hobbies.&lt;/p&gt;

&lt;p&gt;The difference between programming and something like architecture is that the programmers can not only design but actually build the end product themselves.
A single programmer can complete the entire lifecycle of the product from idea to release - and this is extremely
compelling indeed. It gives you feelings of independence and great power at your fingertips - the power to be productive and
expressive at the same time.&lt;/p&gt;

&lt;p&gt;Not only is programming artistic but it&amp;#39;s artistic in a very abstract, platonic sense - similar to music, in the
sense that everything that defines each bit of work is pure information, as opposed to the physical placement of particles
of matter, as for example painting would be. It can be reworked endlessly with no loss of fidelity of the result. The
result is effectively timeless. So long as you&amp;#39;re using Git and cloud I guess ...&lt;/p&gt;

&lt;p&gt;This aspect of abstractness brings about another very important feature of programming - since you&amp;#39;re working in the digital world with no
cost to materials, and in environments that you can access from anywhere and take anywhere with you - you are completely
free to program wherever and whatever you want in your own time, and therefore the personal project becomes possible.&lt;/p&gt;

&lt;p&gt;With personal projects, programmers don&amp;#39;t need any external validation before starting them.
This is extremely liberating. Imagine if you could be an architect and physically create any building that comes to your
mind, then play around with it and explore it, with no cost and with the chance of producing something actually useful
and significant. All the while learning valuable lessons for use in your actual day job!&lt;/p&gt;

&lt;p&gt;However, no matter how much you can enjoy programming as a hobby, you always have to come back down to Earth and get into
the technical details of computer science and technology, in order to do it well. So to be a
programmer you must also have some sort of engineering mindset to want to delve into the details and enjoy that process.
Of the creative and technical dispositions, I&amp;#39;d say it&amp;#39;s most valuable to start off with the first. The creative inspiration
can then be the motivating force required to get you over the barrier and learn all of the technical details that you
need.&lt;/p&gt;

&lt;p&gt;The above factors are why when I started to learn programming, then play around with it, I felt a strong urge to keep
doing it. Perhaps it explains some of the reasons why so many people seem to cross over &lt;em&gt;into&lt;/em&gt; programming from other
fields. At every &lt;a href=&quot;techmeetup.co.uk&quot;&gt;TechMeetup&lt;/a&gt; event I go to I speak to at least one person
who is a student of &lt;a href=&quot;https://codeclan.com&quot;&gt;CodeClan&lt;/a&gt;, and it&amp;#39;s great to be involved in a field where that happens
 and which is so welcoming to people joining.&lt;/p&gt;
</description>
        <pubDate>Tue, 06 Feb 2018 00:00:00 +0000</pubDate>
        <link>https://rsmith.io/blog/whats-so-fun-about-programming/</link>
        <guid isPermaLink="true">https://rsmith.io/blog/whats-so-fun-about-programming/</guid>
        
        
      </item>
    
      <item>
        <title>Personal Automation as Code Practice</title>
        <description>&lt;p&gt;Perhaps one natural tendency of programmers is to want to automate too many things, especially when it comes to their
personal stuff. I say &amp;#39;programmers&amp;#39;, because this will surely apply to at least both software developers and DevOps engineers,
as two disciplines for which people use programming languages and into which I think people often fall as a result programming
as a hobby.&lt;/p&gt;

&lt;p&gt;Whilst trying to get something done in your own time, it can be tempting to think &amp;#39;*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       what if I automated
this?*&amp;#39;. It may feel like a procrastination tool, and maybe it leads you down a rabbit hole of stolen time with no
useful result. Or you automate a task and only ever do it once, finding that perfect, one-use-only regex - there&amp;#39;s that
old adage about programmers.&lt;/p&gt;

&lt;p&gt;I definitely have this tendency, and of course I make use of it in work environments too, but in a work situation I have to be
brutally pragmatic about what is worth automating. For instance, using a build tool to automate your web app build and
initiate a watching/reloading task is one of the most common and time-saving tasks for a web developer.&lt;/p&gt;

&lt;p&gt;At home however I can engage any flight of fancy I like and I&amp;#39;m sure I&amp;#39;m not alone in doing so, but I think it is mostly a
healthy thing. For one thing, being better at spotting tasks that &lt;em&gt;can&lt;/em&gt; be automated seems like a useful skill for a developer
or anybody who uses programming languages in their job to automate things. For another, it can be a useful excuse to
learn a new programming language or tool.&lt;/p&gt;

&lt;p&gt;That last reason is why I decided to learn ZSH inside-out several years ago. I&amp;#39;d only ever had a basic, empirical-type of knowledge of shell
programming languages, so I had only ever written pretty basic scripts in them. So on late nights after work, I started writing ZSH functions
to automate tasks I was doing in the terminal over and over again, and this became quite addictive and fun. It also put me
to sleep pretty effectively.&lt;/p&gt;

&lt;p&gt;As well as automating things I did often, I set
myself coding challenges to do things that &lt;em&gt;weren&amp;#39;t&lt;/em&gt; useful, just to see if I could, and to see how one might do
it in ZSH. It&amp;#39;s not that ZSH or shell languages in general are particularly fun or attractive languages to code in,
but novelty is a stimulating thing and as a programmer you may as well have a better knowledge of shell languages.&lt;/p&gt;

&lt;p&gt;Sometimes a task really &lt;em&gt;was&lt;/em&gt; too hard or annoying to code in ZSH so a few tools written in Python or Ruby have been added.
In this way I also challenged myself to learn Ruby - and, what is now one of the most valuable tools in my toolbox - regex. Yet
another excuse to &lt;a href=&quot;https://rsmith.io/blog/learn-regex-or-regret-it/&quot;&gt;learn regex!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Overall, as with the personal side-project, I think this kind of habit of developers is a great thing, and really
helps to maintain that love for programming, that can sometimes become a little jaded after too much hard work.&lt;/p&gt;
</description>
        <pubDate>Mon, 29 Jan 2018 00:00:00 +0000</pubDate>
        <link>https://rsmith.io/blog/personal-automation-as-code-practice/</link>
        <guid isPermaLink="true">https://rsmith.io/blog/personal-automation-as-code-practice/</guid>
        
        
      </item>
    
      <item>
        <title>When Should You Write Unit Tests?</title>
        <description>&lt;h2&gt;Test-driven development?&lt;/h2&gt;

&lt;p&gt;We&amp;#39;ve probably all heard of &lt;a href=&quot;https://en.wikipedia.org/wiki/Test-driven_development&quot;&gt;TDD&lt;/a&gt; (Test-Driven-Development) by now,
with the idea behind TDD being to write your automated tests before the production code.&lt;/p&gt;

&lt;p&gt;As with all software development practices, you&amp;#39;ll find
people with a whole range of opinions about the pros and cons of different approaches. These kind of debates usually
have limited value after a certain point, because there is no single general solution. The debate can go round and round
in circles but at some point you have to make a decision on what you&amp;#39;re doing to do in a given scenario. I will describe
the main principles I follow in deciding when to write tests.&lt;/p&gt;

&lt;h2&gt;The value of writing automated tests&lt;/h2&gt;

&lt;p&gt;Leaving aside the potential virtues of TDD for now, the value of having
good automated tests &lt;em&gt;at all&lt;/em&gt; far outstrips potential differences between writing them &lt;em&gt;before&lt;/em&gt; or &lt;em&gt;after&lt;/em&gt;.
It&amp;#39;s difficult to argue against the use of a good set of automated tests. The benefits are something I have
thought about a lot; here are the main ones that come to mind:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Automated tests save you time&lt;/strong&gt;. Manual testing is extremely time-consuming, and when you don&amp;#39;t have automated tests,
it&amp;#39;s difficult to make any kind of incremental changes to your code and be confident that it still works. If you are
doing lots of manual testing as you go, this will waste lots of precious time. If you make a lot of code changes and &lt;em&gt;then&lt;/em&gt;
manually test everything all at once, things might be too broken to recover quickly.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With automated tests, you can make many incremental changes and quickly validate them to ensure that you are not
breaking fundamental functionality. You&amp;#39;ll still want to do manual tests at the end of course, but
knowing core logic is still working as you develop allows you to get on with changes quicker. Cutting out even a small percentage
of the brutally-menial work of manual testing amounts to a huge time-saving.&lt;/p&gt;

&lt;p&gt;Particularly for complex code, I find writing an automated test suite up-front to save me a lot of &lt;em&gt;initial&lt;/em&gt; development time,
before I begin counting on-going maintenance time. By the time the automated tests are passing and it comes
to manual testing, it often turns out that things are &lt;em&gt;just working&lt;/em&gt;. This is a great thing to experience.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Automated tests increase reliability&lt;/strong&gt;. Since automated tests are &lt;em&gt;automated&lt;/em&gt;, they always do their job properly. So if you are
happy with your tests, and they pass, then you can be confident that in the worst case, your application is only minimally broken
before you begin manual testing. The application will increase in reliability over time as bugs become known and tested for.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Automated tests help you to understand the code&lt;/strong&gt;. Whenever I need to remind myself of what a particular piece of code does, or I am
familiarising myself with a new codebase, I always find reading the tests to be extremely helpful, especially if they are
written such that they build up in a progression from simple to complex cases.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Automated tests make refactoring much easier&lt;/strong&gt;. Refactoring complex code that doesn&amp;#39;t have tests is a &lt;em&gt;nightmare&lt;/em&gt;! On a large,
complex codebase, a good automated test suite will make refactoring vastly easier. If I was asked to refactor a complex
codebase that lacked automated tests, I would consider writing those tests first. This would have the added benefit of
forcing me to &lt;em&gt;really&lt;/em&gt; understand how the code works, as well as the business domain.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Writing tests helps with code design&lt;/strong&gt;. I find the process of writing tests to be extremely useful in helping to
resolve some design questions I may still have, when producing new code.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Watching a test suite pass is extremely satisfying&lt;/strong&gt;. Watching automated tests go from failing to passing is a great
feeling. This can give you a very tangible feeling of momentum and confidence.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;When &lt;em&gt;not&lt;/em&gt; to write tests before code&lt;/h2&gt;

&lt;p&gt;I&amp;#39;ve found there is one obvious situation where you don&amp;#39;t want to write the unit tests before you write the code:
before the architecture of the code you&amp;#39;re writing is fully defined.&lt;/p&gt;

&lt;p&gt;Automated tests add inertia to change, and this
is part of their value when used wisely, as it makes it harder for yourself or other developers to break things down
the line. Therefore if you&amp;#39;ve written a lot of tests and &lt;em&gt;then&lt;/em&gt; change the design of the code being tested, you&amp;#39;re going
to experience a lot of pain, and the pain will damage your creative process.&lt;/p&gt;

&lt;p&gt;There will still be some situations where the design will need to evolve at least a little as you start to
actually implement it - it&amp;#39;s hard to foresee everything at the start of writing a new codebase, especially if you are
working in a new language or framework for example - in these cases it can be good to be sparing about the tests that
you write first, then fill them in later.&lt;/p&gt;

&lt;h2&gt;When to write tests before code&lt;/h2&gt;

&lt;h3&gt;When the overall architecture is well-defined&lt;/h3&gt;

&lt;p&gt;TDD works best in codebases where the overall architecture is already settled and robust, and you are
just expanding the application horizontally - adding new features, and testing new algorithms. Everything is predictable on a
large scale, and the only unknown is the correctness of the new code you are adding. So for example, you may be adding a new function
to an existing service, adding a new service, or adding a new data model and associated DAO class.&lt;/p&gt;

&lt;p&gt;In the above scenario, the overall structure to the tests you need to write will be obvious and predictable. Once you
reach this point, you can be blindingly fast at adding new features, &lt;em&gt;and&lt;/em&gt; having them well-tested. It is a win-win-win,
and very enjoyable.&lt;/p&gt;

&lt;h3&gt;Write tests whilst the domain and codebase knowledge are fresh&lt;/h3&gt;

&lt;p&gt;I believe it is an important responsibility of the authors and modifiers of complex code, to be writing up automated tests
that are needed as soon as the necessary knowledge of the domain or codebase has been gained. The overhead required of
a developer later on to attain enough knowledge to write the tests themselves and start gaining the benefits of those tests,
is very high. Even a small change to complex code would require a lot of time spent to fully understand the implications,
if these are not made obvious by failing tests.&lt;/p&gt;

&lt;p&gt;It can be a very stressful experience for a developer to have to make modifications to complex code that is
not well-tested. If a great automated test suite is already there, the process becomes much easier and more enjoyable.&lt;/p&gt;

&lt;h2&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Software development is a technical and creative discipline, usually done in a business context. Decisions should be tailored
to each scenario, and these can be highly varied in the life of a programmer.&lt;/p&gt;

&lt;p&gt;The overall goal is to produce working code in the shortest time possible. The effort should go into fully understanding
how each decision will affect the overall development time, possibly in non-obvious ways.&lt;/p&gt;
</description>
        <pubDate>Thu, 25 Jan 2018 00:00:00 +0000</pubDate>
        <link>https://rsmith.io/blog/when-to-write-unit-tests/</link>
        <guid isPermaLink="true">https://rsmith.io/blog/when-to-write-unit-tests/</guid>
        
        
      </item>
    
      <item>
        <title>Dicsaurus</title>
        <description>&lt;p&gt;I&amp;#39;ve created a small tool named &lt;a href=&quot;https://github.com/robinrob/dicsaurus&quot;&gt;Dicsaurus&lt;/a&gt;, out of a need to quickly look up
 words and synonyms for words, and out of a desire to make it as painless as possible.&lt;/p&gt;

&lt;p&gt;Previously I was using the command-line &lt;code&gt;dict&lt;/code&gt; tool in OS X, and for thesaurus just a ZSH function opening &lt;a href=&quot;http://www.thesaurus.com/&quot;&gt;thesaurus.com&lt;/a&gt;
 in a browser, with the search term encoded into a URL parameter.&lt;/p&gt;

&lt;p&gt;Dicsaurus is a simple python script that makes HTTP callouts to &lt;a href=&quot;https://developer.oxforddictionaries.com/&quot;&gt;Oxford Dictionaries API&lt;/a&gt;.
It currently works in two modes: dictionary and thesaurus. The &lt;a href=&quot;https://github.com/robinrob/dicsaurus/blob/master/README.md&quot;&gt;readme&lt;/a&gt;
explains how to set it up, including registering a developer account at &lt;a href=&quot;https://developer.oxforddictionaries.com&quot;&gt;developer.oxforddictionaries.com&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;Example usage in dictionary mode&lt;/h2&gt;

&lt;p&gt;The word &amp;#39;blue&amp;#39; turns out to be a good test word for both dictionary and thesaurus modes.&lt;/p&gt;

&lt;p&gt;Command: &lt;code&gt;./dicsaurus.py -t blue&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Output:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-plaintext&quot; data-lang=&quot;plaintext&quot;&gt;Results from Oxford University Press:

Definition(s) for 'blue'

   blue (Adjective)

      Example(s):
         a blue silk shirt
         the clear blue sky
         deep blue eyes
         he's feeling blue
         a blue movie
         the successful blue candidate

      Etomologie(s):
         Middle English: from Old French bleu, ultimately of Germanic origin and related to Old English blǣwen ‘blue’ and Old Norse blár ‘dark blue’ (see also blaeberry)


   blue (Noun)

      Example(s):
         she was dressed in blue
         armchairs in pastel blues and greens
         the dark blue of his eyes
         a flyweight boxing blue
         did you have a blue or what?
         his tactical blue in saying the opposition wasn't ready to govern
         only an Aussie could make a red-headed man ‘Blue.’


   blue (Verb)

      Example(s):
         blued paper
         the day would haze, the air bluing with afternoon
         the light dims, bluing the retina
         they blued the shirts and starched the uniforms

      Etomologie(s):
         mid 19th century: perhaps a variant of blow&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Example usage in thesaurus mode&lt;/h2&gt;

&lt;p&gt;Command: &lt;code&gt;./dicsaurus.py -t blue&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Output:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-plaintext&quot; data-lang=&quot;plaintext&quot;&gt;Results from Oxford University Press:

Synonym(s) for 'blue'

   blue (Adjective)

      Snynoym(s):
         sky-blue
         azure
         cobalt
         cobalt blue
         sapphire
         cerulean
         navy
         navy blue
         saxe
         saxe blue
         Oxford blue
         Cambridge blue
         ultramarine
         lapis lazuli
         indigo
         aquamarine
         turquoise
         teal
         teal blue
         cyan
         of the colour of the sky
         of the colour of the sea

      Example(s):
         she had bright blue eyes

      Snynoym(s):
         depressed
         down
         sad
         saddened
         unhappy
         melancholy
         miserable
         sorrowful
         gloomy
         dejected
         downhearted
         disheartened
         despondent
         dispirited
         low
         in low spirits
         low-spirited
         heavy-hearted
         glum
         morose
         dismal
         downcast
         cast down
         tearful

      Example(s):
         Dad had died that year and Mum was feeling a bit blue

      Snynoym(s):
         indecent
         dirty
         rude
         coarse
         vulgar
         bawdy
         lewd
         racy
         risqué
         salacious
         naughty
         wicked
         improper
         unseemly
         smutty
         spicy
         raw
         off colour
         ribald
         Rabelaisian

      Example(s):
         a blue movie

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        <pubDate>Fri, 19 Jan 2018 00:00:00 +0000</pubDate>
        <link>https://rsmith.io/blog/dicsaurus-tool/</link>
        <guid isPermaLink="true">https://rsmith.io/blog/dicsaurus-tool/</guid>
        
        
      </item>
    
      <item>
        <title>Python 3.6 String Interpolation</title>
        <description>&lt;p&gt;If you&amp;#39;re one of those Ruby/Python purists look away now.&lt;/p&gt;

&lt;p&gt;I first learned about this new Python 3 syntax for string interpolation around six months ago, and since then I&amp;#39;ve barely
used it because I hadn&amp;#39;t used it enough to remember the syntax. And since it&amp;#39;s recent, Googling for it wasn&amp;#39;t returning
much either - and since I hadn&amp;#39;t realised it was unique to versions 3.6 onwards, I wasn&amp;#39;t looking in the correct documentation versions.&lt;/p&gt;

&lt;p&gt;Essentially Python 3.6 introduces a new form of string interpolation that is similar to the way one can embed variables
into strings in Ruby:
&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;msg = &amp;quot;Hello at last!&amp;quot;
puts &amp;quot;#{msg}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;Same example in Python 3.6:
&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;msg = &amp;quot;Hello at last!&amp;quot;
print(f&amp;quot;{msg}&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;Output:
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;&amp;gt;&amp;gt; Hello at last!
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;Which I find to be a lot nicer than:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;&quot;{msg}&quot;.format(msg=msg)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In most situations.&lt;/p&gt;
</description>
        <pubDate>Sun, 14 Jan 2018 00:00:00 +0000</pubDate>
        <link>https://rsmith.io/blog/python-3-6-string-interpolation/</link>
        <guid isPermaLink="true">https://rsmith.io/blog/python-3-6-string-interpolation/</guid>
        
        
      </item>
    
      <item>
        <title>Going Freelance</title>
        <description>&lt;h2&gt;Background&lt;/h2&gt;

&lt;p&gt;I recently gave a &lt;a href=&quot;https://youtu.be/bdfuv9c3WLM?t=2589&quot;&gt;talk&lt;/a&gt; on going freelance at a &lt;a href=&quot;http://techmeetup.co.uk/&quot;&gt;TechMeetup&lt;/a&gt; event in Edinburgh.
The process of preparing for the talk really got me thinking about my experiences, and I will summarise some of the
things I spoke about here.&lt;/p&gt;

&lt;p&gt;Shortly after I began my first full-time job as a web developer, I began hearing about freelancers through general conversation.
The comments associated with them were usually something about their high pay relative to equivalent full-time employed
workers. Sometimes a colleague would mention that
they had freelanced in the past, before returning to full-time work, which intrigued me.&lt;/p&gt;

&lt;p&gt;Another thing I realised was that the app stores/marketplaces of the main mobile
platforms were mature and I knew there were developers out there who could make a full-time living just by producing
entirely their own applications.&lt;/p&gt;

&lt;p&gt;A few years later, a colleague and good friend admitted that he was even making a small monthly income from the Android Market, for a couple
of apps he had made in-between finishing his PhD and starting his first job. This excited me, whilst at the same time making
myself feel somewhat underachieving! However my priority at the time was to keep building software development and
cloud technology experience, so I filed these ideas away in the back of my mind.&lt;/p&gt;

&lt;p&gt;A few years later, I found myself thinking about freelancing more and more, and eventually decided to set myself a firm target. I
chose a nice round number and decided I wanted to be freelancing by that particular age. Later, a colleague decided to make
the same jump before me, and told me all about his experiences throughout the process, and how much he was enjoying the
benefits of freelancing. Another friend in London revealed he was also contracting in a different area of work.
I chose a date in the following year by which I wanted to be freelancing, and an amount of money I&amp;#39;d
need to have in the bank by then before making the jump (enough to live for at least 6 months without work).&lt;/p&gt;

&lt;p&gt;I managed to beat my age target for beginning freelancing, which is a satisfying feeling. I have now been freelancing
for two and a half years, so I thought it would be nice to write down the main pros and cons from my perspective.&lt;/p&gt;

&lt;h2&gt;The Switch&lt;/h2&gt;

&lt;p&gt;Once I had left my job, I began looking for work. It was an exciting period because time felt critical, and at the same
time I was enjoying the absolute freedom of the break from work. Fortunately, my freelancing software developer friend was able to refer
an enquiry to me, since my friend was busy at the time, and I ended up with a job just a few weeks later after a quick
chat in a cafe. The feeling of satisfaction at succeeding with the first job was great. And once you have reached that point
it is really up to you whether you want to continue with freelancing or not.&lt;/p&gt;

&lt;p&gt;Over time, I found many great benefits to the freelancing lifestyle, including for me the ability to work home.
But there can be drawbacks too, although it is easy to imagine the pros
and cons being completely different for different people. If you find the cons outweigh the pros, you can always go back, so
freelancing is the sort of thing I definitely recommend trying for someone who is considering it, because at the very
least it is a great experience-building experience.&lt;/p&gt;

&lt;h2&gt;Benefits of freelancing (or contracting)&lt;/h2&gt;

&lt;p&gt;There&amp;#39;s a subtle distinction between &amp;#39;freelancing&amp;#39; and &amp;#39;contracting&amp;#39;. But I use &amp;#39;freelancing&amp;#39; loosely - for me it means the freedom to take on contract jobs,
whilst also being responsible for your own learning and keeping up with the technology, and the potential for making
money from personal projects. So it&amp;#39;s to do with independence. These are the benefits i&amp;#39;ve experienced so far:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Independence.&lt;/strong&gt; The feeling of personal independence is extremely rewarding.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pay&lt;/strong&gt;. You get more pay per hour, and as long as you can minimise the gaps between jobs, this results in higher overall
income.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Potential Downsides of freelancing&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Lower job security.&lt;/strong&gt; This is an obvious one, but it will have different importance to different people, depending on their
current circumstances. So you have to weight it based on personal considerations too.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Responsibility&lt;/strong&gt; This can be scary to some, especially when it comes to tax. However if your income situation is complex,
you probably want an accountant anyway. If your only source of income is from freelancing jobs, then I find it to actually
be relatively simple (in the UK), despite the seemingly-complex rules. I know this is a controversial opinion!

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Team integration&lt;/strong&gt; You may be seen as more of an ‘outsider’ when working in a team of full-time employed people, resulting
in weaker team relationships. Just try to be super easy to work with and helpful at all times.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;More time spent on admin, marketing etc. instead of actual job&lt;/strong&gt; As a result of the higher personal responsibility,
a significant amount of your time will be spent not indulging in your passion for coding. However I always say that
everybody needs variety, in both environment and day-to-day tasks. Breaks from strenuous thinking always promote
creativity. Can you tell that I&amp;#39;m an incessant optimist?&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Maybe you could just sell your own products instead?&lt;/strong&gt; If independence is what you are after, then a possibility is
to start working on personal projects whilst doing your full-time job, with the aim to monetise your products.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;No company benefits.&lt;/strong&gt; Such as holidays. Not having paid holiday means that whenever you are going on holiday, the true &amp;#39;cost&amp;#39; of the holiday
now includes the time you spent on holiday multiplied by your rate! When deciding your day rate, you need to take into account all
of the monetary benefits you may be missing out on by going independent. And if you are making enough, then this will not be a worry.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Unpredictable work load&lt;/strong&gt; This is one of those risk factors you must factor in when deciding your day rate, and you have to
judge the risk of each project or job individually. Fortunately in software development at the moment, the demand is fairly high,
so for a good developer making a consistent effort to build contacts and exposure, it is definitely possible to maintain a consistently-high
work load. You can always fill your gaps with work on personal projects. Get to be thinking like an entrepreneur.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Benefits to working from home&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;The ability to work in your own environment.&lt;/strong&gt; We can be more efficient when we can have our surroundings exactly
how we want them. Once you have setup your own personal office, it takes a big variable out of the equation. You
can also cook breakfast and lunch.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Avoiding commutes.&lt;/strong&gt; Doing no commuting at all literally returns hours of the day back to you,
to use however you want. It also means that whilst everybody else in the outside world is stressfully trying to get to work on time, and back,
you have the leisure to spend that on whatever you want. If you like to enjoy hobbies in your spare time, this is a real benefit.
All the good developers have some personal project they&amp;#39;d like to spend more time on.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Flexibility.&lt;/strong&gt; If you are the sort of person
who naturally tends towards the most efficient ways of doing things, this can increase your efficiency a lot. Working from home
leads to being able to precisely setting your own schedule - when to start work, when to have lunch, for how long, and when to finish.
If you need to pop out to do some errand during the day, you can just find a convenient time
and go and do it. Parcels? You are always in, so these are never a problem either. I find this benefit to be priceless.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Added motivation to socialise.&lt;/strong&gt; Working from home can feel isolating at times, but you can turn it into a positive thing
by using that to motivate yourself to socialise more in ways that you may not have otherwise. When you&amp;#39;re around people in an office all day, you may not want to go
and be around even more people in the evening. But when working from home, you really relish it. So start some sociable hobbies that
you may not otherwise have done.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Possible downsides to working from home&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Time-management discipline.&lt;/strong&gt; With the increase in flexibility with your time, comes a great responsibility to manage it well and be efficient. When
you can choose your working hours, you will naturally want to work when it most suits you. But it can also be tempting to
become lazy, even without realising it. Even when you see yourself as a non-lazy person! If you find yourself getting up later than you&amp;#39;d like,
and doing less hours, or working during hours in which you&amp;#39;re less productive, or working at the weekends, it&amp;#39;s important to notice and self-correct these things.
You can come out of it with much clearer goals about what you actually want to achieve, and more therefore motivation and discipline towards achieving those goals.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Loneliness.&lt;/strong&gt; This can take some time to have its effect, but the effect of rarely interacting with people in person during
your working day can be quite
profound. It can lead to a massive loss in productivity in all areas of your life,
and you may not even notice it for a while either. You need to recognise it and find a solution, like changing to a job
where you are working on-site, or a combination of that and working from home. Or working in coffee shops for some of the day.
The great thing is you have the freedom to do something really novel.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;You get sick of your home.&lt;/strong&gt; As well as sapping your motivation for work, this can even put you off doing hobbies that you would
usually do at home. The solutions are similar to the ones for loneliness above.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;The importance of cleanly dividing your work and leisure time I found to be fundamental. My personal choice is actually to work from 8am-4pm,
as these are the hours when I am most productive. It also keeps me in sync with the schedules of friends, with obvious benefits.
As much as we sometimes malign it, the working week is actually pretty-effectively designed!&lt;/p&gt;

&lt;p&gt;To achieve my aim of making a living by freelancing has been very gratifying. The challenge and process of doing
your own marketing and network-building I find to be great fun. There are ways in which I could have being doing these much better,
and I&amp;#39;ve recently learned a lot about this subject. I will be writing about it soon.&lt;/p&gt;

&lt;p&gt;Going into the future, I am completely open-minded about whether I continue freelancing or go back into a
full-time employed position. I can clearly see the advantages of either. At the moment, I am actually swaying towards
the latter. I am neither an evangelist nor detractor for freelancing - everybody can gain something out of it, and
it will be different things to different people. People also change, but the one thing that you should aim to keep constant
is your enthusiasm for your craft, and for people.&lt;/p&gt;
</description>
        <pubDate>Fri, 12 Jan 2018 00:00:00 +0000</pubDate>
        <link>https://rsmith.io/blog/going-freelance/</link>
        <guid isPermaLink="true">https://rsmith.io/blog/going-freelance/</guid>
        
        
      </item>
    
      <item>
        <title>Maintaining a personal code library</title>
        <description>&lt;p&gt;These days rapid Google searches are an invaluable tool for developers who are constantly getting to grips with a
new language, framework or technique, where reading lengthy documentation would be a waste of time when the problem
is simply a matter of finding the correct syntax.&lt;/p&gt;

&lt;p&gt;Very very often I find the answer is much more valuable to me when shown in a way in which it is best understood by
myself. And there are certain things that when you are switching between languages on varying timescales, you find
yourself repeatedly needing to look up. They can often be unique to your particular style of coding - for example
it may be that you want to remind yourself of a particular pattern for implementing a decorator method in Python, or of
implementing a Class and inheritance structure in Javascript. The questions and answers are not always trivial.&lt;/p&gt;

&lt;p&gt;For this reason I am very careful to record in short scripts all such useful examples and commit and push these into
source code repositories that I maintain for myself. I have structured the repositories in a way (one repository per language,
split into &lt;code&gt;practice&lt;/code&gt; and &lt;code&gt;projects&lt;/code&gt; directories), that they are highly
amenable to searching by automated tool (usually ZSH function), so that usually to find the answer to a problem it is
a matter of running one command from wherever I happen to be, and I am instantly reminded of the code that I need.&lt;/p&gt;

&lt;p&gt;Holding onto your precious code is also a matter of pride in craft. Code does not often come cheap and can require
significant expenditure of your time to find good solutions. I do not want that time to go to waste by having to repeat
the process in future.&lt;/p&gt;
</description>
        <pubDate>Fri, 30 Oct 2015 00:00:00 +0000</pubDate>
        <link>https://rsmith.io/blog/personal-code-library/</link>
        <guid isPermaLink="true">https://rsmith.io/blog/personal-code-library/</guid>
        
        
      </item>
    
      <item>
        <title>Learn Regex or Regret It</title>
        <description>&lt;p&gt;Do you like challenging logic puzzles? Games that give you a set of root principles then offer up increasingly hard
problems that require ever-more creative ways of using the root principles to solve?&lt;/p&gt;

&lt;p&gt;I do, and once I actually sat down to dedicate some time to the subject of regular expressions, the
above viewpoint is the way in which I came to view this learning process. Learning how to use regular expressions is an exercise of
applying the known rules of the game to situations that require your creativity, logical thinking and intuition to solve.&lt;/p&gt;

&lt;p&gt;With all things that are difficult to do well, if you can make the process of mastering it into a game you will perform
much better. The task of solving regex problems is a &lt;em&gt;perfect&lt;/em&gt; candidate for game-making!&lt;/p&gt;

&lt;p&gt;If you only reach this stage in your appreciation of regular expressions then you may already find great value in them. But they
are also among one of the few truly powerful tools available to programmers that transcend programming language, framework
or project that you are working on. If you find Javascript to be a language worth learning because of its popularity
and relevance - a mere programming language, or AngularJS a framework worth learning because it&amp;#39;s popular at the
moment - then you should logically view a tool like regular expressions as being of great importance and relevance in your profession.
Regular expressions have been around for decades and have changed little in their basic philosophy and syntax.&lt;/p&gt;

&lt;p&gt;More important than any of the above great reasons for learning how to use regular expressions, the fact remains that they
are an incredibly powerful and efficient way of solving certain types of text-reading and text-manipulation problems.
To take a (simplified) example that is well-suited to the application of a regex solution: let&amp;#39;s say that you want
to read in some user input to specify the first line of an address, which must be a number followed by alphabetical
strings of characters, e.g. &amp;#39;41 Princes Street&amp;#39;. Furthermore, each alphabetical string must have its initial
character capitalised. So &amp;#39;41 123 Princes Street&amp;#39; would be invalid, as would &amp;#39;41 princes Street&amp;#39; or &amp;#39;41 Princes123 Street&amp;#39;. &lt;/p&gt;

&lt;p&gt;Let&amp;#39;s first solve the problem without using a regex. You may write some code like this (for example in Python):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;#!/usr/bin/env python

import sys

address = sys.argv[1]

parts = address.split(' ')

try:
    house_number = int(parts[0])
    street = parts[1:-1]

    for street_part in street:
        assert street_part.istitle() and street_part.isalpha()

    print 'Valid address!'

except Exception as e:
    print 'Invalid address'
    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An equivalent script using a regex method might go like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;#!/usr/bin/env python

import sys, re

address = sys.argv[1]

regex = re.compile('\A[0-9]+ ([A-Z][a-z]+\ ?)+\Z')
res = regex.match(address)

if hasattr(res, 'group'):
    print 'Valid address!'
    
else:
    print 'Invalid address'

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The regular expression says: match a string with the following properties:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Begins with a string of one more more digits&lt;/li&gt;
&lt;li&gt;The initial string of digits is followed by a space character, then one or more of: (alphabetical string with capitalised initial character, optionally followed by a space character)&lt;/li&gt;
&lt;li&gt;The string ends on the last of the occurrence of (alphabetical string with capitalised initial character, optionally followed by a space character)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For this particular example with the given constraints on the format of the address I would prefer the regular expression
solution, as it expresses very concisely the conditions being imposed for validity of the input. For me it is a lot
easier to write and to read and therefore easier to get right and to not make mistakes. It also utilises a neat aspect
of regular expressions: recursive matching of a sub-expression (the alphabetical strings following the number in the address
line).&lt;/p&gt;

&lt;p&gt;Not every instance of any given type of problem is best solved using any particular tool, and this is true with regular 
expressions. A judgement must be made based on many factors and constraints on which is the best method to use to solve the problem,
where &amp;#39;best&amp;#39; is defined by a lot of factors specific to the problem and the environment and circumstances in which it is being solved.
Regular expressions are just one additional tool that you have available for consideration when making this decision.&lt;/p&gt;

&lt;p&gt;The reason why I think that it would be regretful not to learn how to use regular expressions, is that since making the
effort to learn how to use this tool, I have personally encountered many situations where they have been a priceless tool, saving
me time and frustration, and giving a feeling of satisfaction when the correct regex for a problem is discovered! It&amp;#39;s
not often that such a simple, short string of characters can give such power.&lt;/p&gt;
</description>
        <pubDate>Sat, 29 Aug 2015 00:00:00 +0100</pubDate>
        <link>https://rsmith.io/blog/learn-regex-or-regret-it/</link>
        <guid isPermaLink="true">https://rsmith.io/blog/learn-regex-or-regret-it/</guid>
        
        
      </item>
    
  </channel>
</rss>
