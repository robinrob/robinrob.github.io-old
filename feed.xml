<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Robin Smith - Freelance Developer</title>
    <description>Experienced freelance software developer designing and building custom web applications and integrations using modern cloud technologies and frameworks.
</description>
    <link>https://rsmith.io/</link>
    <atom:link href="https://rsmith.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 20 Jul 2015 23:50:43 +0100</pubDate>
    <lastBuildDate>Mon, 20 Jul 2015 23:50:43 +0100</lastBuildDate>
    <generator>Jekyll v2.4.0</generator>
    
      <item>
        <title>ConsoleWriter jQuery Plugin</title>
        <description>&lt;h2 class=&quot;console-writer&quot; cw-sound=&quot;true&quot; cw-animation=&quot;true&quot;&gt;Edit Me!&lt;/h2&gt;

&lt;p&gt;I wanted to create a console-like typing effect on a heading element, with the heading firstly 
appearing character by character as if being typed in at a developer&amp;#39;s console. This sort of thing has already been done
as in &lt;a href=&quot;http://www.mattboldt.com/demos/typed-js/&quot;&gt;Typed.js&lt;/a&gt;,
&lt;a href=&quot;http://codepen.io/voronianski/pen/aicwk&quot;&gt;typeWriter.js&lt;/a&gt; or
&lt;a href=&quot;https://github.com/fardjad/realistic-typewriter.js&quot;&gt;realistic-typewriter.js&lt;/a&gt;. As with most ideas in the JS
world or software world, it is fair to say that this idea has been done before.&lt;/p&gt;

&lt;p&gt;My main motivation for the project was to gain familiarity with using jQuery and I believe that embarking on a pet
project is the best, most fun and most productive way to learn a new programming language or framework. &lt;/p&gt;

&lt;p&gt;The main objective I wanted to achieve was actually to allow the site visitor to modify the heading element by focusing it,
deleting existing characters and typing whatever they wanted into the element, complete with a blinking cursor at the end
of the line as in a terminal. I also added keyboard typing sounds to heighten the effect. Try it now by clicking any of
the headings within this blog article.&lt;/p&gt;

&lt;h2 class=&quot;console-writer&quot; cw-typing-sound=&quot;true&quot;&gt;ConsoleWriter&lt;/h2&gt;

&lt;p&gt;I packaged the project up as a jQuery plugin: &lt;a href=&quot;https://github.com/robinrob/consolewriter.jquery.js&quot;&gt;ConsoleWriter&lt;/a&gt;,
designed with a focus on user-friendliness and configurability using options. The heading above this paragraph displays the default method of usage which requires
just adding the &lt;code&gt;console-writer&lt;/code&gt; class to the element. Reload the page again to see the typewriter effect. The &lt;code&gt;readme&lt;/code&gt;
file included in the repo describes the options and how to set them. There is also a &lt;code&gt;demo.html&lt;/code&gt; file which shows
example usages.&lt;/p&gt;
</description>
        <pubDate>Wed, 01 Jul 2015 00:00:00 +0100</pubDate>
        <link>https://rsmith.io/blog/console-writer-jquery-plugin</link>
        <guid isPermaLink="true">https://rsmith.io/blog/console-writer-jquery-plugin</guid>
        
        
      </item>
    
      <item>
        <title>Jekyll Gulp HAML SASS BrowserSync</title>
        <description>&lt;p&gt;Whilst using Github&amp;#39;s Jekyll framework to build a static website, I noticed a lack of built-in HAML support. I am a big fan of using HAML to produce HTML. Apart from this lack of support for HAML, I enjoy using Jekyll.&lt;/p&gt;

&lt;p&gt;Since I was using Gulp to manage the build process, I needed a Gulp task to handle the HAML preprocessing. I initially tried using the &lt;a href=&quot;https://www.npmjs.com/package/gulp-haml&quot;&gt;gulp-haml&lt;/a&gt; module in my HAML task, but it produced incorrect results a few times. I came across the node module &lt;a href=&quot;https://github.com/moneypenny/gulp-ruby-haml&quot;&gt;gulp-ruby-haml&lt;/a&gt;, which is a wrapper on the Ruby gem &lt;a href=&quot;https://rubygems.org/gems/haml&quot;&gt;haml&lt;/a&gt;, and which gives accurate results.&lt;/p&gt;

&lt;h2 class=&quot;section-heading&quot;&gt;HAML Processing&lt;/h2&gt;

&lt;p&gt;HAML files reside inside a &lt;code&gt;_haml&lt;/code&gt; folder which sits at the location of the resultant HTML files. For example:
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;project-root
        index
                _haml
                        index.haml
                index.html
        _includes
                _haml
                        footer.haml
                        head.haml
                        nav.haml
                footer.html
                head.html
                nav.html
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;The HAML build task is actually fairly slow compared to the CSS or Javascript processing tasks. It can take up to 10 seconds to process all of the HAML in the project. This is unacceptable when rebuilding on-the-fly while making changes.&lt;/p&gt;

&lt;p&gt;To avoid slow build times, I use a separate &lt;code&gt;haml-watch&lt;/code&gt; task that watches the HAML files for changes, then only processes the files that changed. The stream is then piped into the code for compiling the HAML, which is contained in the function &lt;code&gt;hamlBuild()&lt;/code&gt;. This stream-piping step makes use of &lt;a href=&quot;https://www.npmjs.com/package/stream-combiner2&quot;&gt;stream-combiner2&lt;/a&gt;. Below is the code for both HAML tasks:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;var haml = require(&#39;gulp-ruby-haml&#39;)
var combiner = require(&#39;stream-combiner2&#39;)

...

var config = {
    paths: {
        ...
        haml: {
            src: [&#39;**/_haml/*.haml&#39;]
        },
        ...
    }
}

...

/* hamlBuild() contains the shared build logic used by haml-watch and haml-build */
function hamlBuild() {
    return combiner(
        haml(),
        rename(function (path) {
            path.dirname += &#39;/../&#39;
        })
    )
}

/* Watch and compile only changed HAML files to HTML.
 * haml-watch has its own task to avoid doing a full HAML build on each .haml file change, since a full HAML build
 * can be quite slow.
 */
gulp.task(&#39;haml-watch&#39;, function () {
    gulp.src(config.paths.haml.src, {read: false})
        .pipe(watch(config.paths.haml.src))
        .pipe(hamlBuild())
        .pipe(gulp.dest(&#39;./&#39;))
})

/* Compile all HAML files to HTML. */
gulp.task(&#39;haml-build&#39;, function () {
    return gulp.src(config.paths.haml.src)
        .pipe(hamlBuild())
        .pipe(gulp.dest(&#39;./&#39;))
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 class=&quot;section-heading&quot;&gt;Full Site Template&lt;/h2&gt;

&lt;p&gt;Whilst researching Jekyll, I noticed a few other people sharing their Jekyll setups as site templates. Here is my own &lt;a href=&quot;https://github.com/robinrob/jekyll-gulp-haml-sass-browsersync.git&quot;&gt;jekyll-gulp-haml-sass-browsersync&lt;/a&gt; template which includes my full &lt;a href=&quot;https://github.com/robinrob/jekyll-gulp-haml-sass-browsersync/blob/master/gulpfile.js&quot;&gt;Gulpfile&lt;/a&gt;.&lt;/p&gt;
</description>
        <pubDate>Thu, 04 Jun 2015 00:00:00 +0100</pubDate>
        <link>https://rsmith.io/blog/jekyll_gulp_haml_sass_browsersync</link>
        <guid isPermaLink="true">https://rsmith.io/blog/jekyll_gulp_haml_sass_browsersync</guid>
        
        
      </item>
    
  </channel>
</rss>
